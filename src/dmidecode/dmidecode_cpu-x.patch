Only in a/dmidecode: biosdecode.c
Only in b/dmidecode: CMakeLists.txt
diff -ru a/dmidecode/dmidecode.c b/dmidecode/dmidecode.c
--- a/dmidecode/dmidecode.c	2016-01-07 15:20:25.303602004 +0100
+++ b/dmidecode/dmidecode.c	2016-01-07 15:12:25.629597006 +0100
@@ -65,6 +65,7 @@
 #include "dmidecode.h"
 #include "dmiopt.h"
 #include "dmioem.h"
+#include "libdmi.h"
 
 #define out_of_spec "<OUT OF SPEC>"
 static const char *bad_index = "<BAD INDEX>";
@@ -78,6 +79,10 @@
 #define SYS_ENTRY_FILE SYS_FIRMWARE_DIR "/smbios_entry_point"
 #define SYS_TABLE_FILE SYS_FIRMWARE_DIR "/DMI"
 
+/* Options are global */
+struct opt opt;
+char **dmidata[16];
+
 /*
  * Type-independant Stuff
  */
@@ -295,6 +300,18 @@
 		printf(" %u kB", code >> 10);
 }
 
+static char *dmi_bios_runtime_size_str(u32 code)
+{
+	static char size[24];
+
+	if (code & 0x000003FF)
+		sprintf(size, " %u bytes", code);
+	else
+		sprintf(size, " %u kB", code >> 10);
+
+	return size;
+}
+
 static void dmi_bios_characteristics(u64 code, const char *prefix)
 {
 	/* 7.1.1 */
@@ -1135,6 +1152,19 @@
 		printf("Unknown");
 }
 
+static char *dmi_processor_frequency_str(const u8 *p)
+{
+	u16 code = WORD(p);
+	static char freq[10];
+
+	if (code)
+		sprintf(freq, "%u MHz", code);
+	else
+		printf(freq, "Unknown");
+
+	return freq;
+}
+
 /* code is assumed to be a 3-bit value */
 static const char *dmi_processor_status(u8 code)
 {
@@ -2273,6 +2303,25 @@
 	}
 }
 
+static char *dmi_memory_device_size_str(u16 code)
+{
+	static char size[8];
+
+	if (code == 0)
+		strcpy(size, "Empty");
+	else if (code == 0xFFFF)
+		strcpy(size, "Unknown");
+	else
+	{
+		if (code & 0x8000)
+			sprintf(size, "%u kB", code & 0x7FFF);
+		else
+			sprintf(size, "%u MB", code);
+	}
+
+	return size;
+}
+
 static void dmi_memory_device_extended_size(u32 code)
 {
 	code &= 0x7FFFFFFFUL;
@@ -3232,6 +3281,7 @@
 static void dmi_decode(const struct dmi_header *h, u16 ver)
 {
 	const u8 *data = h->data;
+	static int bank = BANK0_0;
 
 	/*
 	 * Note: DMI types 37 and 42 are untested
@@ -3239,42 +3289,54 @@
 	switch (h->type)
 	{
 		case 0: /* 7.1 BIOS Information */
-			printf("BIOS Information\n");
-			if (h->length < 0x12) break;
-			printf("\tVendor: %s\n",
-				dmi_string(h, data[0x04]));
-			printf("\tVersion: %s\n",
-				dmi_string(h, data[0x05]));
-			printf("\tRelease Date: %s\n",
-				dmi_string(h, data[0x08]));
-			/*
-			 * On IA-64, the BIOS base address will read 0 because
-			 * there is no BIOS. Skip the base address and the
-			 * runtime size in this case.
-			 */
-			if (WORD(data + 0x06) != 0)
+			if(opt.flags & FLAG_CPU_X)
 			{
-				printf("\tAddress: 0x%04X0\n",
-					WORD(data + 0x06));
-				printf("\tRuntime Size:");
-				dmi_bios_runtime_size((0x10000 - WORD(data + 0x06)) << 4);
-				printf("\n");
+				iasprintf(dmidata[BRAND],       "%s", dmi_string(h, data[0x04]));
+				iasprintf(dmidata[BIOSVERSION], "%s", dmi_string(h, data[0x05]));
+				iasprintf(dmidata[DATE],        "%s", dmi_string(h, data[0x08]));
+				iasprintf(dmidata[ROMSIZE],     "%s / %u kB",
+				          dmi_bios_runtime_size_str((0x10000 - WORD(data + 0x06)) << 4),
+				          (data[0x09] + 1) << 6);
+			}
+			else
+			{
+				printf("BIOS Information\n");
+				if (h->length < 0x12) break;
+				printf("\tVendor: %s\n",
+					dmi_string(h, data[0x04]));
+				printf("\tVersion: %s\n",
+					dmi_string(h, data[0x05]));
+				printf("\tRelease Date: %s\n",
+					dmi_string(h, data[0x08]));
+				/*
+				 * On IA-64, the BIOS base address will read 0 because
+				 * there is no BIOS. Skip the base address and the
+				 * runtime size in this case.
+				 */
+				if (WORD(data + 0x06) != 0)
+				{
+					printf("\tAddress: 0x%04X0\n",
+						WORD(data + 0x06));
+					printf("\tRuntime Size:");
+					dmi_bios_runtime_size((0x10000 - WORD(data + 0x06)) << 4);
+					printf("\n");
+				}
+				printf("\tROM Size: %u kB\n",
+					(data[0x09] + 1) << 6);
+				printf("\tCharacteristics:\n");
+				dmi_bios_characteristics(QWORD(data + 0x0A), "\t\t");
+				if (h->length < 0x13) break;
+				dmi_bios_characteristics_x1(data[0x12], "\t\t");
+				if (h->length < 0x14) break;
+				dmi_bios_characteristics_x2(data[0x13], "\t\t");
+				if (h->length < 0x18) break;
+				if (data[0x14] != 0xFF && data[0x15] != 0xFF)
+					printf("\tBIOS Revision: %u.%u\n",
+						data[0x14], data[0x15]);
+				if (data[0x16] != 0xFF && data[0x17] != 0xFF)
+					printf("\tFirmware Revision: %u.%u\n",
+						data[0x16], data[0x17]);
 			}
-			printf("\tROM Size: %u kB\n",
-				(data[0x09] + 1) << 6);
-			printf("\tCharacteristics:\n");
-			dmi_bios_characteristics(QWORD(data + 0x0A), "\t\t");
-			if (h->length < 0x13) break;
-			dmi_bios_characteristics_x1(data[0x12], "\t\t");
-			if (h->length < 0x14) break;
-			dmi_bios_characteristics_x2(data[0x13], "\t\t");
-			if (h->length < 0x18) break;
-			if (data[0x14] != 0xFF && data[0x15] != 0xFF)
-				printf("\tBIOS Revision: %u.%u\n",
-					data[0x14], data[0x15]);
-			if (data[0x16] != 0xFF && data[0x17] != 0xFF)
-				printf("\tFirmware Revision: %u.%u\n",
-					data[0x16], data[0x17]);
 			break;
 
 		case 1: /* 7.2 System Information */
@@ -3302,34 +3364,43 @@
 			break;
 
 		case 2: /* 7.3 Base Board Information */
-			printf("Base Board Information\n");
-			if (h->length < 0x08) break;
-			printf("\tManufacturer: %s\n",
-				dmi_string(h, data[0x04]));
-			printf("\tProduct Name: %s\n",
-				dmi_string(h, data[0x05]));
-			printf("\tVersion: %s\n",
-				dmi_string(h, data[0x06]));
-			printf("\tSerial Number: %s\n",
-				dmi_string(h, data[0x07]));
-			if (h->length < 0x09) break;
-			printf("\tAsset Tag: %s\n",
-				dmi_string(h, data[0x08]));
-			if (h->length < 0x0A) break;
-			printf("\tFeatures:");
-			dmi_base_board_features(data[0x09], "\t\t");
-			if (h->length < 0x0E) break;
-			printf("\tLocation In Chassis: %s\n",
-				dmi_string(h, data[0x0A]));
-			if (!(opt.flags & FLAG_QUIET))
-				printf("\tChassis Handle: 0x%04X\n",
-					WORD(data + 0x0B));
-			printf("\tType: %s\n",
-				dmi_base_board_type(data[0x0D]));
-			if (h->length < 0x0F) break;
-			if (h->length < 0x0F + data[0x0E] * sizeof(u16)) break;
-			if (!(opt.flags & FLAG_QUIET))
-				dmi_base_board_handles(data[0x0E], data + 0x0F, "\t");
+			if(opt.flags & FLAG_CPU_X)
+			{
+				iasprintf(dmidata[MANUFACTURER], "%s", dmi_string(h, data[0x04]));
+				iasprintf(dmidata[MBMODEL],      "%s", dmi_string(h, data[0x05]));
+				iasprintf(dmidata[REVISION],     "%s", dmi_string(h, data[0x06]));
+			}
+			else
+			{
+				printf("Base Board Information\n");
+				if (h->length < 0x08) break;
+				printf("\tManufacturer: %s\n",
+					dmi_string(h, data[0x04]));
+				printf("\tProduct Name: %s\n",
+					dmi_string(h, data[0x05]));
+				printf("\tVersion: %s\n",
+					dmi_string(h, data[0x06]));
+				printf("\tSerial Number: %s\n",
+					dmi_string(h, data[0x07]));
+				if (h->length < 0x09) break;
+				printf("\tAsset Tag: %s\n",
+					dmi_string(h, data[0x08]));
+				if (h->length < 0x0A) break;
+				printf("\tFeatures:");
+				dmi_base_board_features(data[0x09], "\t\t");
+				if (h->length < 0x0E) break;
+				printf("\tLocation In Chassis: %s\n",
+					dmi_string(h, data[0x0A]));
+				if (!(opt.flags & FLAG_QUIET))
+					printf("\tChassis Handle: 0x%04X\n",
+						WORD(data + 0x0B));
+				printf("\tType: %s\n",
+					dmi_base_board_type(data[0x0D]));
+				if (h->length < 0x0F) break;
+				if (h->length < 0x0F + data[0x0E] * sizeof(u16)) break;
+				if (!(opt.flags & FLAG_QUIET))
+					dmi_base_board_handles(data[0x0E], data + 0x0F, "\t");
+			}
 			break;
 
 		case 3: /* 7.4 Chassis Information */
@@ -3375,73 +3446,82 @@
 			break;
 
 		case 4: /* 7.5 Processor Information */
-			printf("Processor Information\n");
-			if (h->length < 0x1A) break;
-			printf("\tSocket Designation: %s\n",
-				dmi_string(h, data[0x04]));
-			printf("\tType: %s\n",
-				dmi_processor_type(data[0x05]));
-			printf("\tFamily: %s\n",
-				dmi_processor_family(h, ver));
-			printf("\tManufacturer: %s\n",
-				dmi_string(h, data[0x07]));
-			dmi_processor_id(data[0x06], data + 0x08, dmi_string(h, data[0x10]), "\t");
-			printf("\tVersion: %s\n",
-				dmi_string(h, data[0x10]));
-			printf("\tVoltage:");
-			dmi_processor_voltage(data[0x11]);
-			printf("\n");
-			printf("\tExternal Clock: ");
-			dmi_processor_frequency(data + 0x12);
-			printf("\n");
-			printf("\tMax Speed: ");
-			dmi_processor_frequency(data + 0x14);
-			printf("\n");
-			printf("\tCurrent Speed: ");
-			dmi_processor_frequency(data + 0x16);
-			printf("\n");
-			if (data[0x18] & (1 << 6))
-				printf("\tStatus: Populated, %s\n",
-					dmi_processor_status(data[0x18] & 0x07));
+			if(opt.flags & FLAG_CPU_X)
+			{
+				iasprintf(dmidata[PROC_PACKAGE], "%s", dmi_string(h, data[0x04]));
+				if(dmidata[PROC_BUS] == NULL)
+					iasprintf(dmidata[PROC_BUS], "%s", dmi_processor_frequency_str(data + 0x12));
+			}
 			else
-				printf("\tStatus: Unpopulated\n");
-			printf("\tUpgrade: %s\n",
-				dmi_processor_upgrade(data[0x19]));
-			if (h->length < 0x20) break;
-			if (!(opt.flags & FLAG_QUIET))
 			{
-				printf("\tL1 Cache Handle:");
-				dmi_processor_cache(WORD(data + 0x1A), "L1", ver);
+				printf("Processor Information\n");
+				if (h->length < 0x1A) break;
+				printf("\tSocket Designation: %s\n",
+					dmi_string(h, data[0x04]));
+				printf("\tType: %s\n",
+					dmi_processor_type(data[0x05]));
+				printf("\tFamily: %s\n",
+					dmi_processor_family(h, ver));
+				printf("\tManufacturer: %s\n",
+					dmi_string(h, data[0x07]));
+				dmi_processor_id(data[0x06], data + 0x08, dmi_string(h, data[0x10]), "\t");
+				printf("\tVersion: %s\n",
+					dmi_string(h, data[0x10]));
+				printf("\tVoltage:");
+				dmi_processor_voltage(data[0x11]);
+				printf("\n");
+				printf("\tExternal Clock: ");
+				dmi_processor_frequency(data + 0x12);
 				printf("\n");
-				printf("\tL2 Cache Handle:");
-				dmi_processor_cache(WORD(data + 0x1C), "L2", ver);
+				printf("\tMax Speed: ");
+				dmi_processor_frequency(data + 0x14);
 				printf("\n");
-				printf("\tL3 Cache Handle:");
-				dmi_processor_cache(WORD(data + 0x1E), "L3", ver);
+				printf("\tCurrent Speed: ");
+				dmi_processor_frequency(data + 0x16);
 				printf("\n");
+				if (data[0x18] & (1 << 6))
+					printf("\tStatus: Populated, %s\n",
+						dmi_processor_status(data[0x18] & 0x07));
+				else
+					printf("\tStatus: Unpopulated\n");
+				printf("\tUpgrade: %s\n",
+					dmi_processor_upgrade(data[0x19]));
+				if (h->length < 0x20) break;
+				if (!(opt.flags & FLAG_QUIET))
+				{
+					printf("\tL1 Cache Handle:");
+					dmi_processor_cache(WORD(data + 0x1A), "L1", ver);
+					printf("\n");
+					printf("\tL2 Cache Handle:");
+					dmi_processor_cache(WORD(data + 0x1C), "L2", ver);
+					printf("\n");
+					printf("\tL3 Cache Handle:");
+					dmi_processor_cache(WORD(data + 0x1E), "L3", ver);
+					printf("\n");
+				}
+				if (h->length < 0x23) break;
+				printf("\tSerial Number: %s\n",
+					dmi_string(h, data[0x20]));
+				printf("\tAsset Tag: %s\n",
+					dmi_string(h, data[0x21]));
+				printf("\tPart Number: %s\n",
+					dmi_string(h, data[0x22]));
+				if (h->length < 0x28) break;
+				if (data[0x23] != 0)
+					printf("\tCore Count: %u\n",
+						h->length >= 0x2C && data[0x23] == 0xFF ?
+						WORD(data + 0x2A) : data[0x23]);
+				if (data[0x24] != 0)
+					printf("\tCore Enabled: %u\n",
+						h->length >= 0x2E && data[0x24] == 0xFF ?
+						WORD(data + 0x2C) : data[0x24]);
+				if (data[0x25] != 0)
+					printf("\tThread Count: %u\n",
+						h->length >= 0x30 && data[0x25] == 0xFF ?
+						WORD(data + 0x2E) : data[0x25]);
+				printf("\tCharacteristics:");
+				dmi_processor_characteristics(WORD(data + 0x26), "\t\t");
 			}
-			if (h->length < 0x23) break;
-			printf("\tSerial Number: %s\n",
-				dmi_string(h, data[0x20]));
-			printf("\tAsset Tag: %s\n",
-				dmi_string(h, data[0x21]));
-			printf("\tPart Number: %s\n",
-				dmi_string(h, data[0x22]));
-			if (h->length < 0x28) break;
-			if (data[0x23] != 0)
-				printf("\tCore Count: %u\n",
-					h->length >= 0x2C && data[0x23] == 0xFF ?
-					WORD(data + 0x2A) : data[0x23]);
-			if (data[0x24] != 0)
-				printf("\tCore Enabled: %u\n",
-					h->length >= 0x2E && data[0x24] == 0xFF ?
-					WORD(data + 0x2C) : data[0x24]);
-			if (data[0x25] != 0)
-				printf("\tThread Count: %u\n",
-					h->length >= 0x30 && data[0x25] == 0xFF ?
-					WORD(data + 0x2E) : data[0x25]);
-			printf("\tCharacteristics:");
-			dmi_processor_characteristics(WORD(data + 0x26), "\t\t");
 			break;
 
 		case 5: /* 7.6 Memory Controller Information */
@@ -3681,76 +3761,99 @@
 			break;
 
 		case 17: /* 7.18 Memory Device */
-			printf("Memory Device\n");
-			if (h->length < 0x15) break;
-			if (!(opt.flags & FLAG_QUIET))
+			if((opt.flags & FLAG_CPU_X) && bank <= BANK7_0)
 			{
-				printf("\tArray Handle: 0x%04X\n",
-					WORD(data + 0x04));
-				printf("\tError Information Handle:");
-				dmi_memory_array_error_handle(WORD(data + 0x06));
-				printf("\n");
+				if(strstr(dmi_string(h, data[0x17]), "Empty") != NULL)
+				{
+					iasprintf(dmidata[bank],   "- - - - - -");
+					iasprintf(dmidata[++bank], "- - - - - -");
+				}
+				else
+				{
+					iasprintf(dmidata[bank], "%s %s",
+					          dmi_string(h, data[0x17]),
+					          dmi_string(h, data[0x1A]));
+					iasprintf(dmidata[++bank], "%s @ %uMHz (%s %s)",
+					          dmi_memory_device_size_str(WORD(data + 0x0C)),
+					          (WORD(data + 0x15)),
+					          dmi_memory_device_form_factor(data[0x0E]),
+					          dmi_memory_device_type(data[0x12]));
+				}
+				bank++;
 			}
-			printf("\tTotal Width:");
-			dmi_memory_device_width(WORD(data + 0x08));
-			printf("\n");
-			printf("\tData Width:");
-			dmi_memory_device_width(WORD(data + 0x0A));
-			printf("\n");
-			printf("\tSize:");
-			if (h->length >= 0x20 && WORD(data + 0x0C) == 0x7FFF)
-				dmi_memory_device_extended_size(DWORD(data + 0x1C));
 			else
-				dmi_memory_device_size(WORD(data + 0x0C));
-			printf("\n");
-			printf("\tForm Factor: %s\n",
-				dmi_memory_device_form_factor(data[0x0E]));
-			printf("\tSet:");
-			dmi_memory_device_set(data[0x0F]);
-			printf("\n");
-			printf("\tLocator: %s\n",
-				dmi_string(h, data[0x10]));
-			printf("\tBank Locator: %s\n",
-				dmi_string(h, data[0x11]));
-			printf("\tType: %s\n",
-				dmi_memory_device_type(data[0x12]));
-			printf("\tType Detail:");
-			dmi_memory_device_type_detail(WORD(data + 0x13));
-			printf("\n");
-			if (h->length < 0x17) break;
-			printf("\tSpeed:");
-			dmi_memory_device_speed(WORD(data + 0x15));
-			printf("\n");
-			if (h->length < 0x1B) break;
-			printf("\tManufacturer: %s\n",
-				dmi_string(h, data[0x17]));
-			printf("\tSerial Number: %s\n",
-				dmi_string(h, data[0x18]));
-			printf("\tAsset Tag: %s\n",
-				dmi_string(h, data[0x19]));
-			printf("\tPart Number: %s\n",
-				dmi_string(h, data[0x1A]));
-			if (h->length < 0x1C) break;
-			printf("\tRank: ");
-			if ((data[0x1B] & 0x0F) == 0)
-				printf("Unknown");
-			else
-				printf("%u", data[0x1B] & 0x0F);
-			printf("\n");
-			if (h->length < 0x22) break;
-			printf("\tConfigured Clock Speed:");
-			dmi_memory_device_speed(WORD(data + 0x20));
-			printf("\n");
-			if (h->length < 0x28) break;
-			printf("\tMinimum Voltage:");
-			dmi_memory_voltage_value(WORD(data + 0x22));
-			printf("\n");
-			printf("\tMaximum Voltage:");
-			dmi_memory_voltage_value(WORD(data + 0x24));
-			printf("\n");
-			printf("\tConfigured Voltage:");
-			dmi_memory_voltage_value(WORD(data + 0x26));
-			printf("\n");
+			{
+				printf("Memory Device\n");
+				if (h->length < 0x15) break;
+				if (!(opt.flags & FLAG_QUIET))
+				{
+					printf("\tArray Handle: 0x%04X\n",
+						WORD(data + 0x04));
+					printf("\tError Information Handle:");
+					dmi_memory_array_error_handle(WORD(data + 0x06));
+					printf("\n");
+				}
+				printf("\tTotal Width:");
+				dmi_memory_device_width(WORD(data + 0x08));
+				printf("\n");
+				printf("\tData Width:");
+				dmi_memory_device_width(WORD(data + 0x0A));
+				printf("\n");
+				printf("\tSize:");
+				if (h->length >= 0x20 && WORD(data + 0x0C) == 0x7FFF)
+					dmi_memory_device_extended_size(DWORD(data + 0x1C));
+				else
+					dmi_memory_device_size(WORD(data + 0x0C));
+				printf("\n");
+				printf("\tForm Factor: %s\n",
+					dmi_memory_device_form_factor(data[0x0E]));
+				printf("\tSet:");
+				dmi_memory_device_set(data[0x0F]);
+				printf("\n");
+				printf("\tLocator: %s\n",
+					dmi_string(h, data[0x10]));
+				printf("\tBank Locator: %s\n",
+					dmi_string(h, data[0x11]));
+				printf("\tType: %s\n",
+					dmi_memory_device_type(data[0x12]));
+				printf("\tType Detail:");
+				dmi_memory_device_type_detail(WORD(data + 0x13));
+				printf("\n");
+				if (h->length < 0x17) break;
+				printf("\tSpeed:");
+				dmi_memory_device_speed(WORD(data + 0x15));
+				printf("\n");
+				if (h->length < 0x1B) break;
+				printf("\tManufacturer: %s\n",
+					dmi_string(h, data[0x17]));
+				printf("\tSerial Number: %s\n",
+					dmi_string(h, data[0x18]));
+				printf("\tAsset Tag: %s\n",
+					dmi_string(h, data[0x19]));
+				printf("\tPart Number: %s\n",
+					dmi_string(h, data[0x1A]));
+				if (h->length < 0x1C) break;
+				printf("\tRank: ");
+				if ((data[0x1B] & 0x0F) == 0)
+					printf("Unknown");
+				else
+					printf("%u", data[0x1B] & 0x0F);
+				printf("\n");
+				if (h->length < 0x22) break;
+				printf("\tConfigured Clock Speed:");
+				dmi_memory_device_speed(WORD(data + 0x20));
+				printf("\n");
+				if (h->length < 0x28) break;
+				printf("\tMinimum Voltage:");
+				dmi_memory_voltage_value(WORD(data + 0x22));
+				printf("\n");
+				printf("\tMaximum Voltage:");
+				dmi_memory_voltage_value(WORD(data + 0x24));
+				printf("\n");
+				printf("\tConfigured Voltage:");
+				dmi_memory_voltage_value(WORD(data + 0x26));
+				printf("\n");
+			}
 			break;
 
 		case 18: /* 7.19 32-bit Memory Error Information */
@@ -4351,7 +4454,8 @@
 				h->type >= 128 ? "OEM-specific" : "Unknown");
 			dmi_dump(h, "\t");
 	}
-	printf("\n");
+	if(!(opt.flags & FLAG_CPU_X))
+		printf("\n");
 }
 
 static void to_dmi_header(struct dmi_header *h, u8 *data)
@@ -4759,7 +4863,7 @@
 	return ret;
 }
 
-int main(int argc, char * const argv[])
+int dmidecode(void)
 {
 	int ret = 0;                /* Returned value */
 	int found = 0;
@@ -4767,6 +4871,7 @@
 	size_t size;
 	int efi;
 	u8 *buf;
+	char *argv[] = { "dmidecode (built-in with CPU-X)", NULL };
 
 	if (sizeof(u8) != 1 || sizeof(u16) != 2 || sizeof(u32) != 4 || '\0' != 0)
 	{
@@ -4776,6 +4881,7 @@
 
 	/* Set default option values */
 	opt.devmem = DEFAULT_MEM_DEV;
+#if 0
 	opt.flags = 0;
 
 	if (parse_command_line(argc, argv)<0)
@@ -4795,9 +4901,9 @@
 		printf("%s\n", VERSION);
 		goto exit_free;
 	}
-
+#endif
 	if (!(opt.flags & FLAG_QUIET))
-		printf("# dmidecode %s\n", VERSION);
+		printf("# %s %s\n", argv[0], VERSION);
 
 	/* Read from dump if so instructed */
 	if (opt.flags & FLAG_FROM_DUMP)
@@ -4936,6 +5042,7 @@
 	free(buf);
 exit_free:
 	free(opt.type);
+	opt.type = NULL;
 
 	return ret;
 }
Only in b/dmidecode: dmidecode_cpu-x.patch
diff -ru a/dmidecode/dmiopt.h b/dmidecode/dmiopt.h
--- a/dmidecode/dmiopt.h	2016-01-07 15:20:25.303602004 +0100
+++ b/dmidecode/dmiopt.h	2016-01-07 15:23:35.677603988 +0100
@@ -19,7 +19,6 @@
  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
-#include "types.h"
 
 struct string_keyword
 {
@@ -45,6 +44,7 @@
 #define FLAG_DUMP_BIN           (1 << 4)
 #define FLAG_FROM_DUMP          (1 << 5)
 #define FLAG_NO_SYSFS           (1 << 6)
+#define FLAG_CPU_X              (1 << 10)
 
 int parse_command_line(int argc, char * const argv[]);
 void print_help(void);
Only in a/dmidecode: .gitignore
Only in b/dmidecode: libdmi.h
Only in a/dmidecode: Makefile
Only in a/dmidecode: man
Only in a/dmidecode: ownership.c
Only in a/dmidecode: README
Only in a/dmidecode: vpddecode.c
Only in a/dmidecode: vpdopt.c
Only in a/dmidecode: vpdopt.h
